<!--
  #%L
  Codenjoy - it's a dojo-like platform from developers to developers.
  %%
  Copyright (C) 2018 Codenjoy
  %%
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public
  License along with this program.  If not, see
  <http://www.gnu.org/licenses/gpl-3.0.html>.
  #L%
  -->
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Hero Codenjoy — как играть? | Игры на работе</title>
    <link href="../css/all.min.css" media="all" type="text/css" rel="stylesheet">
    <link href="../css/custom.css" rel="stylesheet">

    <script src="../js/all.min.js"></script>
</head>
<body style="background-color: white;"
      class="single single-post postid-170 single-format-standard logged-in admin-bar singular one-column content customize-support">
<div id="settings" page="rules"></div>
<a href="https://github.com/codenjoyme/codenjoy"><img style="position: absolute; top: 0; right: 0; border: 0;z-index: 100;" src="../../resources/img/fork-me.png" alt="Fork me on GitHub"></a>
<div id="page" class="hfeed">
    <div id="main">
        <div id="primary">
            <div id="content" role="main">
                <header class="entry-header">
                    <h1 class="entry-title">Hero Codenjoy — как играть?</h1>
                </header>

                <div class="entry-content">
                    <div class="page-restrict-output">
                        <p>Игровой demo-сервер доступен так же в интернете 24/7
                            в целях ознакомления <a href="http://codenjoy.com/codenjoy-contest">
                            http://codenjoy.com/codenjoy-contest</a></p>

                        <p>Игра с открытым исходным кодом. Для реализации своей игры, исправления
                            ошибок в текущей и внесения других правок необходимо для начала
                            <a href="https://github.com/codenjoyme/codenjoy">форкнуть проект</a>.
                            В корне репозитория есть описание в файле Readme.md - там описано, что делать дальше.</p>

                        <p>По возникающим вопросам, пиши в <a href="skype:alexander.baglay">skype:alexander.baglay</a>
                            или на почту <a href="mailto:apofig@gmail.com">apofig@gmail.com</a></p>

                        <h2>В чем суть игры?</h2>

                        <p>Надо написать своего бота для героя, который обыграет других
                            ботов по очкам. Все играют на одном поле. Герой может передвигаться
                            по свободным ячейкам во все четыре стороны.</p>

                        <p>Герой может также поставить зелье. Зелье взорвется через 5 тиков
                            (секунд). Ядовитые газы от зелья могут зацепить обитателей поля.
                            Все, кто был задет - исчезает. С помощью зелья можно открывать сундуки.
                            Пострадать можно и на своем, и на чужом зелье. </p>

                        <p>На своем пути герой может повстречать призрака - призрачная субстанция, уничтожающая на своем пути всех героев. </p>

                        <p>Каждый разрушенный объект на поле (герой, призрак, сундуки)
                            тут же восстанавливается в другом месте. Если пострадал герой,
                            ему зачисляются штрафные очки -50*. </p>

                        <p>Герой, от зелья которого были открыты сундуки или уничтожены другие участники на карте получит
                            бонусные очки: за открытый сундук  +10*, за призрака +100*, за
                            другого героя +1000*. </p>

                        <p>*Tочную сумму очков уточни у ведущего.</p>

                        <p>Очки суммируются. Побеждает игрок с большим числом очков (до условленного
                            времени).</p>

                        <p>Итак, игрок <a href="register?gameName=hero">
                            регистрируется на сервере</a>, указывая свой email</p>

                        <p>Далее необходимо подключиться <a href="resources/user/hero-servers.zip">из кода</a>
                            к серверу через вебсокеты. Это Maven проект и подойдет он для игры на JVM языках.
                            Так же в архиве ты найдешь и сырцы для других языков.
                            Как его запустить смотри в корне проекта в файле README.txt</p>

                        <p>Если ты не можешь найти свой язык - придется написать свой клиент
                            (а после пошарить с нами на почту: apofig@gmail.com)</p>

                        <p>Адрес для подключения к игре на сервере http://codenjoy.com:</p>

                        <pre>ws://codenjoy.com:80/codenjoy-contest/ws?user=3edq63tw0bq4w4iem7nb&code=12345678901234567890</pre>

                        <p>Адрес для подключения к игре на сервере, развернутом в локальной сети:</p>

                        <pre>ws://server_ip:8080/codenjoy-contest/ws?user=3edq63tw0bq4w4iem7nb&code=12345678901234567890</pre>

                        <p>Тут 'user' - id игрока, a 'code' - твой security token, его ты можешь получить из адресной
                            строки браузера после регистрации/логина</p>

                        <p>После подключения клиент будет регулярно (каждую секунду) получать строку
                            символов — с закодированным состоянием поля. Формат таков</p>

                        <pre>^board=(.*)$</pre>

                        <p>с помощью этого regexp можно выкусить строку доски.
                            Вот пример строки от сервера:</p>

                        <pre>board=☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼ #   # #  #♥#  #  #  &        #☼☼♥☼♥☼♥☼#☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼#☼#☼♥☼#☼#☼☼#♥♥  ♥#   # #♥   # ♥#          ☼☼ ☼ ☼#☼ ☼♥☼ ☼ ☼#☼ ☼ ☼ ☼ ☼&☼ ☼ ☼ ☼☼     ♥          # #            ☼☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼♥☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼#       # #       ☺& 2  #  #  #☼☼#☼♥☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼☼#  # ♥#               # ♥   #  ☼☼ ☼ ☼#☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼☼   #♥ #      #                 ☼☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼☼     ## #     #   # #   ♥      ☼☼ ☼ ☼♥☼ ☼ ☼#☼ ☼#☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼☼       #♥       #      ## # ###☼☼ ☼ ☼ ☼#☼ ☼ ☼#☼ ☼ ☼#☼#☼&☼ ☼ ☼ ☼ ☼☼       #       #    ♣# #     ♥ ☼☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼☼        ## ## ♥             # #☼☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼                   &    ###  ##☼☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼                   ♥ ##        ☼☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼♥☼#☼ ☼ ☼ ☼☼     ##         &#         #   ☼☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼☼   #   #         #     # &     ☼☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼#☼ ☼☼  #                    ##   &  ☼☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼☼ #    # &        #       #     ☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>

                        <p>Длинна строки равна площади поля. Если вставить символ переноса строки
                            каждые sqrt(length(string)) символов, то получится читабельное
                            изображение поля.</p>

<pre>☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼
☼ #   # #  #♥#  #  #  &        #☼
☼♥☼♥☼♥☼#☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼#☼#☼♥☼#☼#☼
☼#♥♥  ♥#   # #♥   # ♥#          ☼
☼ ☼ ☼#☼ ☼♥☼ ☼ ☼#☼ ☼ ☼ ☼ ☼&☼ ☼ ☼ ☼
☼     ♥          # #            ☼
☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼♥☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼#       # #       ☺& 2  #  #  #☼
☼#☼♥☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼
☼#  # ♥#               # ♥   #  ☼
☼ ☼ ☼#☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼
☼   #♥ #      #                 ☼
☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼
☼     ## #     #   # #   ♥      ☼
☼ ☼ ☼♥☼ ☼ ☼#☼ ☼#☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼
☼       #♥       #      ## # ###☼
☼ ☼ ☼ ☼#☼ ☼ ☼#☼ ☼ ☼#☼#☼&☼ ☼ ☼ ☼ ☼
☼       #       #    ♣# #     ♥ ☼
☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼
☼        ## ## ♥             # #☼
☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼                   &    ###  ##☼
☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼                   ♥ ##        ☼
☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼♥☼#☼ ☼ ☼ ☼
☼     ##         &#         #   ☼
☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼
☼   #   #         #     # &     ☼
☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼#☼ ☼
☼  #                    ##   &  ☼
☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼
☼ #    # &        #       #     ☼
☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>

                        <p>Первый символ строки соответствует ячейке расположенной в левом
                            верхнем углу и имеет координату [0, 32]. В этом примере — позиция
                            бомбермена (символ ☺) — [19, 25]. Левый нижний угол имеет координату [0, 0].</p>

                        <p>Расшифровка символов на рисунке ниже</p>

                        <pre>public enum Element {

    /// Твой герой
    HERO('☺'),               // герой
    POTION_HERO('☻'),        // герой под которым варится зелье
    DEAD_HERO('Ѡ'),          // ойкс! твой герой умер. Не волнуйся, он появится
                             // через секунду где-нибудь на поле, но вполне
                             // вероятно за это ты получишь штрафные очки.

    /// Игроки противники (из другой команды)
    ENEMY_HERO('ö'),         // герой-противник
    ENEMY_POTION_HERO('Ö'),  // герой-противник под которым варится зелье
    ENEMY_DEAD_HERO('ø'),    // так, если герой-противник уничтожен.
                             // если это твоя заслуга - ты получишь бонусные очки.

    /// Игроки из твоей команды (или игроки противники, если игра не командная)
    OTHER_HERO('♥'),         // другой герой
    OTHER_POTION_HERO('♠'),  // другой герой под которым варится зелье
    OTHER_DEAD_HERO('♣'),    // другой герой уничтожен.
                             // если это твоя заслуга - ты получишь бонусные очки.
                             // но только если это не командная игра - тогда штрафные.

    /// зелье
    POTION_TIMER_5('5'),     // после того как герой поставит зелье таймер вкючится (всего 5 тиков)
    POTION_TIMER_4('4'),     // это зелье закипит через 4 тика
    POTION_TIMER_3('3'),     // это - через 3
    POTION_TIMER_2('2'),     // два
    POTION_TIMER_1('1'),     // один
    BOOM('҉'),               // Пуф! Это то, как зелье взрывается. При этом всех, кого можно уничтожить - будут уничтожены,
                             // закрытые сундуки - откроются.

    /// стены
    WALL('☼'),                 // неразрушаемые стены - им пары зелья не страшны

    /// сундуки
    TREASURE_BOX('#'),         // а это сундук с сокровищами, может быть открыт
    OPENING_TREASURE_BOX('H'), // это как открытый сундук выглядит, она пропадет в следующую секунду
                               // если это ты сделал - ты получишь бонусные очки

    /// ghosts
    GHOST('&'),              // этот малый бегает по полю в произвольном порядке
                             // если он дотронется до героя - тот умрет
                             // его можно уничтожить с помощью зелья и заработать бонусные очки
    DEAD_GHOST('x'),         // это уничтоженный призрак

    /// perks
    /// Значения, таймауты, вероятность выпадения перков могут быть изменены администратором игры.
    /// Указаны значения по умолчанию.
    /// Действие перка истекает по таймауту (10 тиков) если не указано иначе в описании перка.

    POTION_BLAST_RADIUS_INCREASE('+'), // увеличивает радиус распространения ядовитых паров (радиус +2 к текущему).
                                       // Действует только для вновь установленных зелий.

    POTION_COUNT_INCREASE('c'),        // Увеличивает количество доступных игроку зелий (+3 к текущему уровню по-умолчанию).

    POTION_IMMUNE('i'),                // Дает иммунитет от ядовитых паров.

    POTION_REMOTE_CONTROL('r'),        // Дистанционный детонатор. Срабатывает при повторном действии. 3 детонатора по умолчанию.

    POISON_THROWER('T'),               // Ядомет. Позволяет герою стрелять ядом. Радиус действия такой же как и у зелья.
                                       // Активируется командой АСТ(1)+Направление(например: RIGHT,ACT(1) ), работает паралельно с установкой зелий.
                                       // После применения необходима "перезарядка". (по-умолчанию 3 тика)

    POTION_EXPLODER('A'),              // Детонатор всех зелий на поле. Позволяет игроку взорвать все существующие зелья на поле независимо от их владельца и типа.
                                       // Активируется командой АСТ(2).

    /// a void
    NONE(' ');                         // свободная ячейка, куда ты можешь направить героя</pre>

                        <p>Игра пошаговая, каждую секунду сервер посылает твоему клиенту (боту) состояние
                            обновленного поля на текущий момент и ожидает ответа команды герою.
                            За следующую секунду игрок должен успеть дать команду герою.
                            Если не успел — герой стоит на месте.</p>

                        <p>Команд несколько: UP, DOWN, LEFT, RIGHT – приводят к движению героя в
                            заданном направлении на 1 клетку; ACT - оставить зелье на
                            месте героя. Команды движения можно комбинировать с командой ACT, разделяя
                            их через запятую. Порядок (LEFT, ACT) или (ACT, LEFT) - имеет значение,
                            либо двигаемся влево и там ставим зелье, либо ставим зелье а затем ходим
                            влево. Если игрок будет использовать только одну команду ACT, то зелье
                            установится под героем без его перемещения на поле. </p>

                        <p>Команда АСТ(1). Используется только при наличии перка POISON_THROWER. Позволяет
                            бросить в сторону противника пары яда. Используется в паре с командой смены направления
                            движения, разделенные через запятую. Порядок (LEFT, ACT(1)) или (ACT(1), LEFT) - значения не имеет.
                            Без указания направления ничего не произойдет, герой останется стоять на месте. </p>

                        <p>Первая задача – написать websocket клиента, который подключится к серверу.
                            Затем заставить героя слушаться команды. Таким образом, игрок подготовится
                            к основной игре. Основная цель – вести осмысленную игру и победить.</p>

                        <p>Сейчас реализованы клиенты для игры для некоторых языков программирования
                            (Java, Javascript, Objective-C, C++, Python, C#) Другие языки в процессе
                            написания (спасибо игрокам-активистам!).</p>

                        <p>Слишком много форы клиентский код не дает играющим, поскольку в этом коде
                            еще надо разобраться, но там реализована логика общения с сервером +
                            некоторое высокоуровневое API для работы с доской (что уже приятно)</p>

                        <pre>Point getHero()                          // позиция моего бомбера на доске
Collection&lt;Point&gt; getOtherHeroes()           // позиции всех остальных героев (из твоей команды) на доске
Collection&lt;Point&gt; getEnemyHeroes()           // позиции героев противника на доске
boolean isMyHeroDead()                       // жив ли мой бомбер
boolean isAt(Point point, Element element)    // находится ли в позиции point заданный элемент?
boolean isAt(Point point, Collection&lt;Element&gt; elements)   // находится ли в позиции point что-нибудь из заданного набора
boolean isNear(Point point, Element element)  // есть ли вокруг клеточки с координатой point заданный элемент
boolean isBarrierAt(Point point)              // есть ли препятствие в клеточке point
int countNear(Point point, Element element)   // сколько элементов заданного типа есть вокруг клетки с point
Element getAt(Point point)                    // возвращает элемент в текущей клетке
int boardSize()                               // возвращает размер доски
Collection&lt;Point&gt; getBarriers()               // координаты всех объектов препятствующих движению
Collection&lt;Point&gt; getGhosts()                 // координаты всех призраков
Collection&lt;Point&gt; getWalls()                  // координаты всех бетонных стен
Collection&lt;Point&gt; getTreasureBoxes()          // координаты всех сундуков с сокровищами (их можно открывать)
Collection&lt;Point&gt; getBombs()                  // координаты всех зелий
Collection&lt;Point&gt; getFutureBlasts()           // координаты потенциально опасных мест, где зелье может взорваться.
                                                  // (зелье распространяется на N {решим перед началом игры} клеточек
                                                  // в стороны: вверх, вниз, вправо, влево)
Тут:
Point       // координата x, y
Collection  // набор нескольких объектов
Element     // тип элемента на доске </pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
