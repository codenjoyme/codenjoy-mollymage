<meta charset="UTF-8">

## Вступление

Игровой demo-сервер доступен так же в интернете 24/7 в целях
ознакомления [http://codenjoy.com/codenjoy-contest](http://codenjoy.com/codenjoy-contest).

Игра с открытым исходным кодом. Для реализации своей игры, исправления
ошибок в текущей и внесения других правок необходимо для начала
[форкнуть проект](https://github.com/codenjoyme/codenjoy).
В корне репозитория есть описание в файле Readme.md - там описано, что делать дальше.

По возникающим вопросам, пиши в [skype alexander.baglay](skype:alexander.baglay)
или на почту [apofig@gmail.com](mailto:apofig@gmail.com).

## В чем суть игры?

Надо написать своего бота для героя, который обыграет других
ботов по очкам. Все играют на одном поле. Герой может передвигаться
по свободным ячейкам во все четыре стороны.

Герой может также поставить зелье. Зелье взорвется через 5 тиков
(секунд). Ядовитые газы от зелья могут зацепить обитателей поля.
Все, кто был задет - исчезает. С помощью зелья можно открывать сундуки.
Пострадать можно и на своем, и на чужом зелье. 

На своем пути герой может повстречать призрака - призрачная субстанция, уничтожающая на своем пути всех героев. 

Каждый разрушенный объект на поле (герой, призрак, сундуки)
тут же восстанавливается в другом месте. Если пострадал герой,
ему зачисляются штрафные очки -50*. 

Герой, от зелья которого были открыты сундуки или уничтожены другие участники на карте получит
бонусные очки: за открытый сундук  +10*, за призрака +100*, за
другого героя +1000*. 

*Tочную сумму очков уточни у ведущего.

Очки суммируются. Побеждает игрок с большим числом очков (до условленного
времени).

## Подключение к серверу

Итак, игрок [регистрируется на сервере](../../../register?gameName=mollymage),
указывая свой email.

Далее необходимо подключиться [из кода](../../../resources/mollymage/user/clients.zip)
к серверу через websocket. Это Maven проект и подойдет он для игры на JVM языках.
Так же в архиве ты найдешь и сырцы для других языков.
Как его запустить смотри в корне проекта в файле README.txt

Если ты не можешь найти свой язык - придется написать свой клиент
(а после пошарить с нами на почту: [apofig@gmail.com](mailto:apofig@gmail.com))

Адрес для подключения к игре на сервере http://codenjoy.com:

`ws://codenjoy.com:80/codenjoy-contest/ws?user=[user]&code=[code]`

Адрес для подключения к игре на сервере, развернутом в локальной сети:

`ws://[server]:8080/codenjoy-contest/ws?user=[user]&code=[code]`

Тут `[server]` - ip-адрес сервера, `[user]` - id игрока, a `[code]` -
твой security token, его ты можешь получить из адресной
строки браузера после регистрации/логина.

После подключения клиент будет регулярно (каждую секунду) получать строку
символов — с закодированным состоянием поля. Формат таков:

`^board=(.*)$`

с помощью этого regexp можно выкусить строку доски.
Вот пример строки от сервера:

<pre>board=☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼ #   # #  #♥#  #  #  &        #☼☼♥☼♥☼♥☼#☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼#☼#☼♥☼#☼#☼☼#♥♥  ♥#   # #♥   # ♥#          ☼☼ ☼ ☼#☼ ☼♥☼ ☼ ☼#☼ ☼ ☼ ☼ ☼&☼ ☼ ☼ ☼☼     ♥          # #            ☼☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼♥☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼#       # #       ☺& 2  #  #  #☼☼#☼♥☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼☼#  # ♥#               # ♥   #  ☼☼ ☼ ☼#☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼☼   #♥ #      #                 ☼☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼☼     ## #     #   # #   ♥      ☼☼ ☼ ☼♥☼ ☼ ☼#☼ ☼#☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼☼       #♥       #      ## # ###☼☼ ☼ ☼ ☼#☼ ☼ ☼#☼ ☼ ☼#☼#☼&☼ ☼ ☼ ☼ ☼☼       #       #    ♣# #     ♥ ☼☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼☼        ## ## ♥             # #☼☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼                   &    ###  ##☼☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼                   ♥ ##        ☼☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼♥☼#☼ ☼ ☼ ☼☼     ##         &#         #   ☼☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼☼   #   #         #     # &     ☼☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼#☼ ☼☼  #                    ##   &  ☼☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼☼ #    # &        #       #     ☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>

Длинна строки равна площади поля. Если вставить символ переноса строки
каждые `sqrt(length(string))` символов, то получится читабельное
изображение поля.

<pre>☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼
☼ #   # #  #♥#  #  #  &        #☼
☼♥☼♥☼♥☼#☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼#☼#☼♥☼#☼#☼
☼#♥♥  ♥#   # #♥   # ♥#          ☼
☼ ☼ ☼#☼ ☼♥☼ ☼ ☼#☼ ☼ ☼ ☼ ☼&☼ ☼ ☼ ☼
☼     ♥          # #            ☼
☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼♥☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼#       # #       ☺& 2  #  #  #☼
☼#☼♥☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼
☼#  # ♥#               # ♥   #  ☼
☼ ☼ ☼#☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼
☼   #♥ #      #                 ☼
☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼
☼     ## #     #   # #   ♥      ☼
☼ ☼ ☼♥☼ ☼ ☼#☼ ☼#☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼
☼       #♥       #      ## # ###☼
☼ ☼ ☼ ☼#☼ ☼ ☼#☼ ☼ ☼#☼#☼&☼ ☼ ☼ ☼ ☼
☼       #       #    ♣# #     ♥ ☼
☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼
☼        ## ## ♥             # #☼
☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼                   &    ###  ##☼
☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼                   ♥ ##        ☼
☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼♥☼#☼ ☼ ☼ ☼
☼     ##         &#         #   ☼
☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼
☼   #   #         #     # &     ☼
☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼#☼ ☼
☼  #                    ##   &  ☼
☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼
☼ #    # &        #       #     ☼
☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>

Первый символ строки соответствует ячейке расположенной в левом
верхнем углу и имеет координату [0, 32]. В этом примере — позиция
бомбермена (символ ☺) — [19, 25]. Левый нижний угол имеет координату [0, 0].

Расшифровка символов на рисунке ниже

<pre>public enum Element {

/// Твой герой
HERO('☺'),               // герой
POTION_HERO('☻'),        // герой под которым варится зелье
DEAD_HERO('Ѡ'),          // ойкс! твой герой умер. Не волнуйся, он появится
// через секунду где-нибудь на поле, но вполне
// вероятно за это ты получишь штрафные очки.

/// Игроки противники (из другой команды)
ENEMY_HERO('ö'),         // герой-противник
ENEMY_POTION_HERO('Ö'),  // герой-противник под которым варится зелье
ENEMY_DEAD_HERO('ø'),    // так, если герой-противник уничтожен.
// если это твоя заслуга - ты получишь бонусные очки.

/// Игроки из твоей команды (или игроки противники, если игра не командная)
OTHER_HERO('♥'),         // другой герой
OTHER_POTION_HERO('♠'),  // другой герой под которым варится зелье
OTHER_DEAD_HERO('♣'),    // другой герой уничтожен.
// если это твоя заслуга - ты получишь бонусные очки.
// но только если это не командная игра - тогда штрафные.

/// зелье
POTION_TIMER_5('5'),     // после того как герой поставит зелье таймер вкючится (всего 5 тиков)
POTION_TIMER_4('4'),     // это зелье закипит через 4 тика
POTION_TIMER_3('3'),     // это - через 3
POTION_TIMER_2('2'),     // два
POTION_TIMER_1('1'),     // один
BOOM('҉'),               // Пуф! Это то, как зелье взрывается. При этом всех, кого можно уничтожить - будут уничтожены,
// закрытые сундуки - откроются.

/// стены
WALL('☼'),                 // неразрушаемые стены - им пары зелья не страшны

/// сундуки
TREASURE_BOX('#'),         // а это сундук с сокровищами, может быть открыт
OPENING_TREASURE_BOX('H'), // это как открытый сундук выглядит, она пропадет в следующую секунду
// если это ты сделал - ты получишь бонусные очки

/// ghosts
GHOST('&'),              // этот малый бегает по полю в произвольном порядке
// если он дотронется до героя - тот умрет
// его можно уничтожить с помощью зелья и заработать бонусные очки
DEAD_GHOST('x'),         // это уничтоженный призрак

/// perks
/// Значения, таймауты, вероятность выпадения перков могут быть изменены администратором игры.
/// Указаны значения по умолчанию.
/// Действие перка истекает по таймауту (10 тиков) если не указано иначе в описании перка.

POTION_BLAST_RADIUS_INCREASE('+'), // увеличивает радиус распространения ядовитых паров (радиус +2 к текущему).
// Действует только для вновь установленных зелий.

POTION_COUNT_INCREASE('c'),        // Увеличивает количество доступных игроку зелий (+3 к текущему уровню по-умолчанию).

POTION_IMMUNE('i'),                // Дает иммунитет от ядовитых паров.

POTION_REMOTE_CONTROL('r'),        // Дистанционный детонатор. Срабатывает при повторном действии. 3 детонатора по умолчанию.

POISON_THROWER('T'),               // Ядомет. Позволяет герою стрелять ядом. Радиус действия такой же как и у зелья.
// Активируется командой АСТ(1)+Направление(например: RIGHT,ACT(1) ), работает паралельно с установкой зелий.
// После применения необходима "перезарядка". (по-умолчанию 3 тика)

POTION_EXPLODER('A'),              // Детонатор всех зелий на поле. Позволяет игроку взорвать все существующие зелья на поле независимо от их владельца и типа.
// Активируется командой АСТ(2).

/// a void
NONE(' ');                         // свободная ячейка, куда ты можешь направить героя</pre>

Игра пошаговая, каждую секунду сервер посылает твоему клиенту (боту) состояние
обновленного поля на текущий момент и ожидает ответа команды герою.
За следующую секунду игрок должен успеть дать команду герою.
Если не успел — герой стоит на месте.

## Commands

Команд несколько: 
* `UP`, `DOWN`, `LEFT`, `RIGHT` – приводят к движению героя в
  заданном направлении на 1 клетку.
* `ACT` - оставить зелье на месте героя. Также, если у героя есть перк 
  `POTION_REMOTE_CONTROL` - он может взорвать свое зелье дистанционно 
  по второй команде `ACT` тогда, когда ему это потребуется.
* `АСТ,<DIRECTION>`,`<DIRECTION>,АСТ` - команды движения можно
  комбинировать с командой `ACT`, разделяя их через запятую. Порядок 
  `LEFT,ACT` или `ACT,LEFT` - имеет значение, либо двигаемся 
  влево и там ставим зелье, либо ставим зелье, а затем ходим
  влево. Если игрок будет использовать только одну команду `ACT`, то зелье
  установится под героем без его перемещения на поле. 
* `АСТ(1),<DIRECTION>` - Используется только при наличии перка 
  `POISON_THROWER`. Позволяет бросить в сторону противника 
  пары яда. Используется в паре с командой смены направления 
  движения, разделенные через запятую. Порядок
  `LEFT,ACT(1)` или `ACT(1),LEFT` - значения не имеет. Без указания 
  направления ничего не произойдет, герой останется стоять на месте.
* `ACT(2)` - работает только с перком `POTION_EXPLODER`. После вызова 
  команды все зелья на поле взрываются одновременно. Действует на все 
  зелья (собственные, командные, вражеские, дистанционные).
  Может использоваться как одна команда и может сочетаться с направлением.
  Пример: `RIGHT,ACT(2)` - в этом случае Молли попытается двигаться 
  вправо, после чего все зелья на поле взорвутся.

Первостепенная задача – написать websocket клиента, который подключится к серверу.
Затем заставить героя слушаться команды. Таким образом, игрок подготовится
к основной игре. Основная цель – вести осмысленную игру и победить.

Сейчас реализованы клиенты для игры для некоторых языков программирования. 
Другие языки в процессе написания (спасибо игрокам-активистам!).

Слишком много форы клиентский код не дает играющим, поскольку в этом коде
еще надо разобраться, но там реализована логика общения с сервером +
некоторое высокоуровневое API для работы с доской (что уже приятно).

Все языки так или иначе имеют похожий набор методов:

* `Point` 
  Координаты `x`, `y`.
* `Collection` 
  Набор нескольких объектов.
* `Element` 
  Тип элемента на доске.
* `int boardSize();` 
  Размер доски.
* `boolean isAt(Point point, Element element);` 
  Находится ли в позиции point заданный элемент?
* `boolean isAt(Point point, Collection<Element> elements);` 
  Находится ли в позиции point что-нибудь из заданного набора?
* `boolean isNear(Point point, Element element);` 
  Есть ли вокруг клеточки с координатой point заданный элемент?
* `boolean isBarrierAt(Point point);` 
  Есть ли препятствие в клеточке point?
* `int countNear(Point point, Element element);` 
  Сколько элементов заданного типа есть вокруг клетки с point?
* `Element getAt(Point point);` 
  Элемент в текущей клетке.
* `Point getHero();` 
  Позиция моего героя на доске.
* `boolean isGameOver();` 
  Жив ли мой герой?
* `Collection<Point> getOtherHeroes();` 
  Позиции всех остальных героев (из твоей команды) на доске.
* `Collection<Point> getEnemyHeroes();` 
  Позиции героев противника на доске.
* `Collection<Point> getBarriers();` 
  Позиции всех объектов препятствующих движению.
* `Collection<Point> getGhosts();` 
  Позиции всех призраков.
* `Collection<Point> getWalls();` 
  Позиции всех бетонных стен.
* `Collection<Point> getTreasureBoxes();` 
  Позиции всех сундуков с сокровищами (их можно открывать).
* `Collection<Point> getBombs();` 
  Позиции всех зелий.
* `Collection<Point> getFutureBlasts();` 
  Позиции потенциально опасных мест, где зелье может взорваться. 
  (зелье распространяется на N {решим перед началом игры} клеточек 
  в стороны: вверх, вниз, вправо, влево).

Удачи и пусть победит сильнейший! 